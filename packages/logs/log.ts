import { Axiom } from '@axiomhq/js';
import { config, env } from '@repo/config';
import pino from 'pino';
import {
  GlobalContextStorageProvider,
  lambdaRequestTracker,
  pinoLambdaDestination,
} from 'pino-lambda';
import pretty from 'pino-pretty';

/** Whether we're running in an AWS deployment */
const IS_AWS = !!(process.env.LAMBDA_TASK_ROOT || process.env.AWS_EXECUTION_ENV);

// ---------- DESTINATIONS ----------
/** Our axiom client */
const axiom = env.AXIOM_TOKEN
  ? new Axiom({
      token: env.AXIOM_TOKEN,
    })
  : undefined;
/** Our lambda destination (ensures things are formatted for cloudwatch) */
const lambdaDest = pinoLambdaDestination();
/** Our pretty destination (ensures things are formatted for the console) */
const prettyDest = pretty({
  colorize: true,
  translateTime: 'SYS:HH:mm:ss',
  // Ignore some params that we don't care about locally
  ignore: 'env,userId,trpc,awsRequestId,apiRequestId,x-correlation-id',
});

// ---------- HELPERS ----------
/** Adds lambda request context to the current request context */
export const addLambdaRequestContext = lambdaRequestTracker();

/** Gets the current request context */
export const getLogMetadata = () => {
  return { ...GlobalContextStorageProvider.getContext() };
};

/** Adds metadata to the current request context */
export const addLogMetadata = (metadata: Record<string, unknown>) => {
  GlobalContextStorageProvider.updateContext(metadata);
};

/** Ensures all logs are flushed */
export const flushLogs = async () => {
  try {
    if (axiom) await axiom.flush();
  } catch (error) {
    console.error('[log] Failed to flush logs:', error);
  }
};

/** The message format generated by pino */
type PinoLog = {
  level: string;
  msg: string;
  [key: string]: unknown;
};

// ---------- PINO ----------
/** Create a custom destination that handles all our destinations */
const customDestination = {
  write: (payload: string) => {
    try {
      // When we're running in AWS, we need to do a few things
      if (IS_AWS) {
        // We should structure the logs for cloudwatch
        lambdaDest.write(payload);

        // Since we can't see the logs easily, we should also send logs to Axiom (if it's configured)
        if (axiom) {
          // Format the payload to be the way axiom expects it
          const { time, ...context } = JSON.parse(payload) as PinoLog;
          axiom.ingest(env.AXIOM_DATASET, [{ _time: time, ...context }]);
        }
      }
      // If we're running locally, show the pretty output
      else prettyDest.write(payload);
    } catch (error) {
      console.error('[log] Failed to handle log:', error);
    }
  },
};

// Create our logging instance
export const log = pino(
  {
    level: process.env.LOG_LEVEL || 'info',
    formatters: {
      level: (label) => ({ level: label }),
    },
    // Attach any global context variables
    base: {
      env: config.stage,
    },
    // Add any additional global context into our logs
    mixin: () => {
      return getLogMetadata();
    },
  },
  customDestination
);
